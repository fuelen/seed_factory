defmodule SeedFactory.Requirements.CommandGraph.Node do
  @moduledoc false
  @enforce_keys [:name, :required_by]

  @derive {Inspect, optional: [:conflict_groups, :requires]}
  defstruct [:name, :required_by, conflict_groups: [], requires: MapSet.new()]

  def new(params) do
    struct!(__MODULE__, params)
  end

  def add_conflict_group(%__MODULE__{} = node, conflict_group) do
    conflict_groups = [conflict_group | node.conflict_groups]
    %{node | conflict_groups: conflict_groups}
  end

  def replace_conflict_group(%__MODULE__{} = node, old, new) do
    conflict_groups = [new | List.delete(node.conflict_groups, old)]
    %{node | conflict_groups: conflict_groups}
  end

  def remove_conflict_group(%__MODULE__{} = node, conflict_group) do
    conflict_groups = List.delete(node.conflict_groups, conflict_group)
    %{node | conflict_groups: conflict_groups}
  end

  def require_node(%__MODULE__{} = node, node_name_to_add) do
    %{node | requires: MapSet.put(node.requires, node_name_to_add)}
  end

  def unrequire_node(%__MODULE__{} = node, node_name_to_remove) do
    %{node | requires: MapSet.delete(node.requires, node_name_to_remove)}
  end

  def set_required_by(%__MODULE__{} = node, required_by) do
    %{node | required_by: required_by}
  end

  def merge_required_by(%__MODULE__{} = node, required_by) do
    %{
      node
      | required_by: Map.merge(node.required_by, required_by, fn _, v1, v2 -> v1 ++ v2 end)
    }
  end

  def requested_explicitly?(%__MODULE__{} = node) do
    Map.has_key?(node.required_by, nil)
  end

  def resolved_args(%__MODULE__{} = node) do
    node.required_by
    |> Map.values()
    |> List.flatten()
    |> squash_args()
  end

  defp squash_args(traits, initial_args \\ %{}) do
    Enum.reduce(traits, initial_args, fn trait, acc ->
      case trait.exec_step do
        %{args_pattern: nil, generate_args: nil, args_match: nil} ->
          acc

        %{args_pattern: pattern} when is_map(pattern) ->
          try do
            deep_merge_maps!(acc, pattern, [])
          catch
            {:conflict, v1, v2, path} ->
              raise ArgumentError, """
              Cannot merge arguments generated by traits for command #{inspect(trait.exec_step.command_name)}.
                Path: #{inspect(path)}
                Value 1: #{inspect(v1)}
                Value 2: #{inspect(v2)}
              """
          end

        %{generate_args: generate_args, args_match: args_match} ->
          try do
            deep_merge_maps!(acc, generate_args.(), [])
          catch
            {:conflict, _v1, _v2, _path} ->
              if args_match.(acc) do
                acc
              else
                raise ArgumentError, """
                Cannot apply trait #{inspect(trait.name)} of entity #{inspect(trait.entity)} to generated args for command #{inspect(trait.exec_step.command_name)}.
                Generated args: #{inspect(acc)}
                """
              end
          end
      end
    end)
  end

  defp deep_merge_maps!(map1, map2, path) do
    Map.merge(map1, map2, fn
      key, v1, v2 when is_map(v1) and is_map(v2) and not is_struct(v1) and not is_struct(v2) ->
        deep_merge_maps!(v1, v2, path ++ [key])

      _key, v, v ->
        v

      key, v1, v2 ->
        throw({:conflict, v1, v2, path ++ [key]})
    end)
  end
end
